# 3TS-Coo 实验报告

> Author: 朱康乐 北京航空航天大学

这是本次开源项目第一阶段的实验，实验使用3TS Coo 工具，目的是为了理解与验证隔离级别。主要的工作就是跑通实验流程，并且理解结果，撰写实验报告。

通过阅读 Coo: Consistency Check for Transactional Databases 这篇论文，我们可以知道，3TS-Coo 是一个黑盒的、性价比高的一致性检查工具。核心一致性检查模块是 generator 和 checker，其独立于数据库。generator 根据我们对 anomaly 的定义提供类似 SQL 的quires 和 schedules，checker 识别执行的 schedules 的一致和不一致行为。 每个定义的 anomaly 将通过 ODBC 向测试数据库发出并行事务来单独测试。 3TS-Coo 一致性检查准确（所有类型的 anomaly）、用户友好（基于 SQL 的测试）、成本效益高（几分钟即可检查一次）。

本阶段的实验大致分为两个步骤，首先要安装 3TS-Coo 所需要的所有依赖，然后再针对每一种数据库，配置好相对应的环境，成功连接数据库后，运行项目获得测试结果。然后获取测试结果，并分析结果。

我在安装过程中，参考了环境和数据库安装的文档，并且使用 chatGPT 和搜索引擎帮我解决了很多问题。由于参考文档的安装环境是Centos7，而我使用的是Ubuntu 22.04，所以很多安装步骤并不适用。因此，需要详细记录下本次实验的过程，方便以后参考和学习使用。

[TOC]

## 1.安装依赖

首先是安装前置依赖环节，以下是实验的过程记录。

实验环境: Ubuntu 22.04.3 LTS，MySQL v8.0.34

**安装 网络工具和SSH**

```bash
sudo apt update
# 安装网络工具
sudo apt install net-tools
# 查看虚拟机IP
ifconfig
# 安装SSH服务
sudo apt install openssh-server
ps -e | grep sshd
service ssh status
# 允许ssh通过防火墙
sudo ufw allow ssh
```

![image-20230823180551167](assets\image-20230823180551167.png)

使用shell工具测试连接，连接成功即可。

**安装 CMake**

```bash
# 安装cmake
sudo apt install cmake
# 查看cmake版本验证安装成功
cmake --version
```

![image-20230823180118973](assets\image-20230823180118973.png)

此外，需要安装 C++ 编译器和 gflags

```bash
# 安装C++编译器g++
sudo apt install g++
# 查看g++是否安装成功
g++ --version
# 安装gflags
sudo apt install libgflags-dev
```

**安装 ODBC**

```bash
# 安装ODBC
sudo apt install unixodbc
sudo apt install unixodbc-dev
sudo apt install odbcinst
# 查看安装是否成功
odbcinst -j
```

![image-20230823180319488](assets\image-20230823180319488.png)

**拉取项目**

> 拉取项目注意切换代码分支，本次实验的代码在coo-consistency-check分支下。

```bash
# 安装git
sudo apt install git
# 生成密钥
ssh-keygen
# 将公钥存储到github上
cat /root/.ssh/id_rsa.pub
# 拉取代码
git clone -b coo-consistency-check git@github.com:Tencent/3TS.git
```

![image-20230822114418280](assets\image-20230822114418280.png)

### MySQL 环境

> 由于实验需要跑很多不同的数据库，因此每个数据库都需要安装配置环境，先以MySQL为例，使用MySQL作为第一个测试的数据库，在后面的结果分析章节中会配置每一种数据库并运行测试。
>
> 数据库的安装大同小异，都是需要先安装数据库，然后安装connector与数据库进行通讯，创建用户测试连接。

**安装 MySQL**

```bash
# 下载文件
wget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_8.0.33-1ubuntu22.04_amd64.deb-bundle.tar
# 安装解压工具
sudo apt install tar
# 解压文件
tar -xvf mysql-server_8.0.33-1ubuntu22.04_amd64.deb-bundle.tar
# 安装MySQL相关文件
dpkg -i mysql-common_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i mysql-community-client-plugins_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i mysql-community-client-core_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i mysql-community-client_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i mysql-client_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i libmysqlclient21_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i libmysqlclient-dev_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i mysql-community-server-core_8.0.33-1ubuntu22.04_amd64.deb
sudo apt --fix-broken install
dpkg -i mysql-community-server_8.0.33-1ubuntu22.04_amd64.deb
# 如果报错则修复依赖关系
sudo apt --fix-broken install
# 查看MySQL是否安装成功
mysql --version
```

![image-20230823195249685](assets\image-20230823195249685.png)

```bash
mysql -uroot -p123456
```

```mysql
# 创建远程登录用户(在MySQL中执行)
create user 'test123'@'%' identified by 'test123' ;
grant all on *.* to 'test123'@'%' ;
flush privileges ;
# 查询用户是否成功创建
use mysql;
select user, host from user ;
```

![image-20230823195530384](assets\image-20230823195530384.png)

**安装 mysql-connector-odbc**

```bash
# 下载并安装mysql-connector-odbc
wget https://downloads.mysql.com/archives/get/p/10/file/mysql-connector-odbc_8.0.33-1ubuntu22.04_amd64.deb
dpkg -i mysql-connector-odbc_8.0.33-1ubuntu22.04_amd64.deb
# 如果报错则修复依赖关系
sudo apt --fix-broken install
# 查看ODBC驱动程序的安装信息和配置文件路径
odbcinst -j
```

```ini
# 在unixODBC的配置文件中添加MySQL数据源和驱动
// /etc/odbc.ini
[mysql]
Description=MySQL test database
Trace=Yes
TraceFile=mysql_sql.log
Driver=MySQL
SERVER=localhost
USER=test123
PASSWORD=test123
PORT=3306
DATABASE=3ts

// /etc/odbcinst.ini
[MySQL]
Description=ODBC for MySQL
Driver=/usr/lib/x86_64-linux-gnu/odbc/libmyodbc8w.so
Setup=/usr/lib/x86_64-linux-gnu/odbc/libmyodbc8w.so
FileUsage=1
```

```bash
# 查找驱动文件路径
find / -name libmyodbc8w.so
```

![image-20230823200228214](assets\image-20230823200228214.png)

**测试连接**

```bash
# isql工具测试连接
isql -v mysql test123 test123
```

![image-20230823200506877](assets\image-20230823200506877.png)

此时，基本的运行环境已经配置完成，接下来就是运行项目开始测试了。

## 2.运行项目

### V1

**构建编译**

生成Makefile文件(执行命令要在项目/3TS/src/dbtest下)并编译。

```bash
cd ~/3TS/src/dbtest/
# 构建项目
cmake -S ./
# 编译代码
make
```

![image-20230823201027150](assets\image-20230823201027150.png)

![image-20230823201106622](assets\image-20230823201106622.png)

> 如果构建项目出现odbc相关错误要参考install文档修改相关配置文件，详见Config部分。

![image-20230823201125204](assets\image-20230823201125204.png)

**配置参数**

例如：要测试 MySQL 数据库，就需要在 auto_test.sh 中修改对应的连接用户密码。

```bash
vim ./auto_test.sh
```

![image-20230823201315112](assets\image-20230823201315112.png)

**运行项目**

```bash
# 测试一个数据库的一个隔离级别
# 这里以read-uncommitted级别为例
./auto_test.sh "mysql" "read-uncommitted"
# ./auto_test.sh "mysql" "read-committed"
# ./auto_test.sh "mysql" "repeatable-read"
# ./auto_test.sh "mysql" "serializable"

# 测试全部数据库的全部指定隔离级别
./auto_test_all.sh
```

正常运行：

![image-20230823201456307](assets\image-20230823201456307.png)

```bash
+ db=mysql
+ isolation=read-uncommitted
+ '[' mysql == sqlserver ']'
+ '[' mysql == mysql ']'
+ ./3ts_dbtest -isolation=read-uncommitted -db_type=mysql -user=test123 -passwd=test123 -case_dir=mysql
input param-> 
  db_type: mysql
  user: test123
  passwd: test123
  isolation: read-uncommitted
----------read test sequence and test result set start----------
t/pg/rat_sda_dirty_read.txt read success
----------init db_connector start----------
init db_connector success
----------set TXN_ISOLATION = read-uncommitted----------
set TXN_ISOLATION = read-uncommitted success
./mysql/read-uncommitted/rat_sda_dirty_read.txt
#### db_type: mysql ####
#### test_type: sda_dirty_read ####
#### isolation: read-uncommitted ####

current_result: The query result of the current SQL statement. Each row of table is separated by a space, and the fields in each row are separated by commas
expected_result: The expected result is the expected query result for each SQL that conforms to the serializability theory
 
----------rat_sda_dirty_read test prepare----------
Q0-T1 execute sql: 'DROP TABLE IF EXISTS t1;'
Q0-T1 execute sql: 'CREATE TABLE t1 (k INT PRIMARY KEY, v INT);'
Q0-T1 execute sql: 'INSERT INTO t1 VALUES (0, 0);'
Q0-T1 execute opt: 'COMMIT';

----------rat_sda_dirty_read test run----------
Q1-T1 execute opt: 'BEGIN;'
Q1 finished at: 2023-8-23 20:13:43:875:223
Q2-T1 execute sql: 'UPDATE t1 SET v=1 WHERE k=0;'
Q2 finished at: 2023-8-23 20:13:43:876:52
                                        Q3-T2 execute opt: 'BEGIN;'
                                        Q3 finished at: 2023-8-23 20:13:43:975:465
                                        Q4-T2 execute sql: 'SELECT * FROM t1 WHERE k = 0;'
                                           current_result: 
                                             (0,1) 
                                           (1) expected_result: 
                                             (0,0) 
                                        Q4 finished at: 2023-8-23 20:13:43:976:532
Q5-T1 execute opt: 'ROLLBACK';
Q5 finished at: 2023-8-23 20:13:44:76:350
                                        Q6-T2 execute opt: 'COMMIT';
                                        Q6 finished at: 2023-8-23 20:13:44:175:599
                                                                                Q7-T3 execute sql: 'SELECT * FROM t1;'
                                                                                   current_result: 
                                                                                     (0,0) 
                                                                                  *(1) expected_result: 
                                                                                     (0,0) 
                                                                                Q7 finished at: 2023-8-23 20:13:44:176:835
                                                                                Q8-T3 execute opt: 'COMMIT';
                                                                                Q8 finished at: 2023-8-23 20:13:44:177:267
Test Result: Anomaly
Reason: Data anomaly is not recognized by the database, resulting in data inconsistencies
```

**结果**

测试结果：异常

原因：数据库未识别数据异常，导致数据不一致

> 如果遇到了如下图问题，是缺失了文件夹。这是因为项目的文件夹结构并不是完整的，需要手动创建空文件夹，如果命令指定了mysql和read-uncommitted，则在mysql文件夹下创建空文件夹read-uncommitted。

![image-20230823201544653](assets\image-20230823201544653.png)

运行结果在项目目录/3TS/src/dbtest/mysql/result_summary或以隔离级别命名的文件夹中。

![image-20230823202131743](assets\image-20230823202131743.png)

### V2

**随机生成待检查异常**

```bash
# 备份do_test_list.txt
cp ~/3Ts/src/dbtest/do_test_list.txt bk_do_test_list.txt
cd ~/3TS/src/dbtest/src/
vim random_do_list.py
```

修改：

```python
do_test_list = "do_test_list.txt" ---> do_test_list = "/root/3TS/src/dbtest/do_test_list.txt"
```

生成待检查异常：

```bash
# argv1：key的个数
# argv2：每个key被⼏个事务操作
python3 random_do_list.py 2 2
```

结果：

```txt
# do_test_list.txt
PW0-PW1
PW0-PCW1
PW0-PI1
PW0-PCI1
PW0-RW1
PW0-RCW1
PW0-RI1
PW0-RCI1
PW0-WP1
...
```

**生成测试用例**

```bash
cd ~/3TS/src/dbtest/src/
vim mda_generate.py
```

修改：

```python
---> case_folder = "/root/3TS/src/dbtest/t/test_case_v2"
---> do_test_list = "/root/3TS/src/dbtest/do_test_list.txt"
```

生成用例：

```bash
# argv1: [tdsql] => for pg/sql standard queries
# argv2: [single,distributed] => for local test or distributed test
python3 mda_generate.py mysql single
```

结果：

```bash
# /root/3TS/src/dbtest/t/test_case_v2
...
-rw-r--r-- 1 root root   594  8月 23 20:43 II0-ICI1.txt
-rw-r--r-- 1 root root   601  8月 23 20:43 II0-ICP1.txt
-rw-r--r-- 1 root root   593  8月 23 20:43 II0-ICR1.txt
-rw-r--r-- 1 root root   594  8月 23 20:43 II0-ICW1.txt
-rw-r--r-- 1 root root   593  8月 23 20:43 II0-II1.txt
-rw-r--r-- 1 root root   600  8月 23 20:43 II0-IP1.txt
-rw-r--r-- 1 root root   592  8月 23 20:43 II0-IR1.txt
-rw-r--r-- 1 root root   593  8月 23 20:43 II0-IW1.txt
...
```

**运行项目**

```bash
cd ~/3TS/src/dbtest
# 将auto_test.sh中指定数据库下的./3ts_dbtest改成./3ts_dbtest_v2
# 在auto_test_all.sh选择想要测试的数据库和隔离级别
./auto_test_all.sh
```

![image-20230823204614130](assets\image-20230823204614130.png)

![image-20230823205210478](assets\image-20230823205210478.png)

结果：

```bash
# /root/3TS/src/dbtest/mysql/read-committed
# 这⾥以mysql下read-committed为例
...
-rw-r--r-- 1 root root  1768  8月 23 21:42 IP0-ICI1.txt
-rw-r--r-- 1 root root  1820  8月 23 21:40 IP0-ICP1.txt
-rw-r--r-- 1 root root  1811  8月 23 21:40 IP0-ICR1.txt
-rw-r--r-- 1 root root  1785  8月 23 21:41 IP0-ICW1.txt
-rw-r--r-- 1 root root  1615  8月 23 21:42 IP0-II1.txt
-rw-r--r-- 1 root root  1814  8月 23 21:40 IP0-IP1.txt
-rw-r--r-- 1 root root  1808  8月 23 21:40 IP0-IR1.txt
-rw-r--r-- 1 root root  1614  8月 23 21:41 IP0-IW1.txt
...
```

**结果检测**

```bash
cd ~/3TS/src/dbtest/src
vim mda_detect.py
```

修改：

```python
# 这⾥以mysql下read-committed为例
---> working_directory = "/root/3TS/src/dbtest/"
---> run_result_folder = working_directory + "mysql/read-committed"
---> result_folder = working_directory + "/check_result/" + "mysql/read-committed"
---> do_test_list = working_directory + "do_test_list.txt"
```

检测结果：

```bash
cd ~/3TS/src/dbtest/src
python3 mda_detect
```

结果：

```bash
# /root/3TS/src/dbtest/check_result/mysql/read-committed
...
PW0-PW1: Cyclic
1->PW->2->PW->1

PW0-PCW1: Cyclic
1->PW->2->PCW->1

PW0-PI1: Cyclic
1->PW->2->PI->1

PW0-PCI1: Cyclic
1->PW->2->PCI->1

PW0-RW1: Cyclic
1->PW->2->RW->1

...
```

## 3.结果分析

通过阅读 Coo: Consistency Check for Transactional Databases 这篇论文，首先对一些名词进行解释：

**名词解释**

| 名词                                  | 解释                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| Object                                | 对象                                                         |
| Operation                             | 操作                                                         |
| Transaction                           | 事务                                                         |
| Object-oriented operations            | 面向对象操作。Opi 表示可能的调用集，表示通过事务Ti对一个对象读和写。 |
| State-expressed operations            | 状态表达操作，包括 Commit(C) 和 Abort(A)。                   |
| Transaction                           | T，是一组操作，交互对象，最后有或没有状态表达操作，代表已提交或活动状态，我们用下标表示事务编号。例如 Opi[xn] 表示通过事务 Ti 面向对象 x 的操作。 |
| Schedules                             | 计划表，时间表。                                             |
| History                               | H，包括T是操作对象的一组事务集合，E是事务T的一组操作集合，E保持事务中的顺序并遵守对象版本顺序<s。 |
| Conflict dependency 和 Conflict graph | 每个 history 都与一个冲突图（也称为有向序列化图）相关联，其中节点是提交的事务，边是事务之间的冲突（读写、写写、写读），冲突图用于测试 schedule 是否可串行化。直观上，非循环冲突图表示可序列化的调度，从而表示一致的执行和最终状态。 |
| Partial Order Pair Graph              | POP图，偏序对图                                              |
| RAT                                   | Read Anomaly Type，读异常类型，环中有写写偏序。              |
| WAT                                   | Write Anomaly Type，写异常类型，环中有一个或者多个写读偏序，且不包含写写偏序。 |
| IAT                                   | Intersect Anomaly Type，交叉异常类型， 除了写异常和读异常之外的异常。 |
| SDA                                   | Single Data Anomaly，单元数据异常，数据异常发生在两个事务一个变量上。 |
| DDA                                   | Single Data Anomaly，双元数据异常，数据异常发生在两个事务两个变量上。 |
| MDA                                   | Single Data Anomaly，多元数据异常                            |

### 实验结果

**统计**

下图表格是我使用 3TS-Coo 工具进行测试的实验结果统计图。在表格中，不同底色和字母代表了不同的实验结果，绿色P表示测试结果为 Avoid，黄色A表示测试结果为 Anomaly，红色D表示测试结果为 Deadlock。而最特殊的是蓝色底色的结果，在 SER 隔离级别下，测试 Lost Update 和 Lost Update Committed 用例时，原本实验文档的 Result 为 Deadlock，而我测试的实验结果却是 Avoid。除此之外，其余结果均与实验文档的 Result 一致。

![image-20230829140518182](assets\image-20230829140518182.png)

#### Lost Update 和 Lost Update Committed

在所有的统计结果中，最为不同的就是蓝色底的两个测试用例。因为

这两个测试用例都是测试有关丢失更新这一异常的。

显然，在 MySQL v8.0.34版本下测试得到的结果是不符合实验预期的，并且也不符合我对 MySQL 的认知。

**结果对比**

对比在 SER 隔离级别下，不同版本 MySQL 跑 Lost Update 和 Lost Update Committed 这两个测试用例所产生的结果。

这是实验文档原有的 Result：

wat_sda_lost_update_c1

![image-20230829140907838](assets\image-20230829140907838.png)

iat_sda_lost_update_committed

![image-20230829135440816](assets\image-20230829135440816.png)

这是我使用 3TS-Coo 工具跑出来的实验结果：

wat_sda_lost_update_c1

![image-20230829140928983](assets\image-20230829140928983.png)

iat_sda_lost_update_committed

![image-20230829140843019](assets\image-20230829140843019.png)

**流程分析**

事务1在 SER 隔离级别下，开启了事务；事务2尝试更新k=0时的值v=2，进入了阻塞，没有执行（没有finish）；事务1更新了k=0时的值v=1，然后提交了事务1；此时

**猜测原因**

可以看到，确实是产生了不一致的结果。低版本的 MySQL 会产生死锁，而最新版本的 MySQL 并没有产生任何异常、

查看生成的所有实验结果发现，我实验所使用的 MySQL 版本为v8.0.34和实验文档 Result 的 MySQL 版本v8.0.20不同，导致在 SER 隔离级别下，Lost Update 和 Lost Update Committed 这一测试用例的测试结果和原有测试结果不同。

首先第一反应猜测的是 MySQL 应该在最新版本中更新了某些内容，先自己手写 SQL 语句测试一下，再去0官网查看更新的文档说明。

**原因分析**

## 4.总结

